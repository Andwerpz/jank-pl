#include <iostream>;
#include <assert>;
#include <crypto/chacha20>;
#include <random>;

string keystring(void* key) {
    return to_hexstring(key, $u64 32);
}

string to_hexstring(void* buf, u64 len) {
    string res = new string(len * 0x2, ' ');
    for(u64 i = 0x0; i < $u64 len; i++) {
        u64 lo = $u64 ($u8* buf)[i] & 0x0F;
        u64 hi = $u64 ($u8* buf)[i] & 0xF0;
        hi >>= $u64 4;
        if(hi < $u64 10) res[i * 0x2 + 0x0] = ('0' + $u8 hi);
        else res[i * 0x2 + 0x0] = ('a' + $u8 hi - $u8 10);
        if(lo < $u64 10) res[i * 0x2 + 0x1] = ('0' + $u8 lo);
        else res[i * 0x2 + 0x1] = ('a' + $u8 lo - $u8 10);
    }
    return res;
}

void from_hexstring(u8* str, void* buf) {
    u64 len = strlen(str);
    assert((len % 0x2) == 0x0, "hexstring invalid");
    for(u64 i = 0x0; i < len; i++) {
        u8 dig = str[i];
        if('0' <= dig && dig <= '9') dig -= '0';
        else if('a' <= dig && dig <= 'f') dig -= 'a' - $u8 10;
        else if('A' <= dig && dig <= 'F') dig -= 'A' - $u8 10;
        else assert(0, "parse hexstring failed");
        u8 cshift = $u8 0x0;
        if((i % 0x2) == 0x0) cshift = $u8 0x4;
        ($u8* buf)[i / 0x2] |= dig << cshift;
    }
} 

void keystream_test(void* key, void* nonce, u64 len) {
    chacha20_ctx ctx;
    chacha20_init(@ctx, key, $u32 1, nonce);
    
    void* stream = malloc(len);
    chacha20_keystream(@ctx, len, stream);
    cout << "KEY : " << to_hexstring(stream, len) << "\n";
    free(stream, len);
}

void encrypt_test(void* key, void* nonce, void* msg, u64 msg_len, u8* exp) {
    chacha20_ctx ctx;
    chacha20_init(@ctx, key, $u32 1, nonce);
    chacha20_apply(@ctx, msg, msg_len);

    cout << "MSG : " << to_hexstring(msg, msg_len) << "\n";
    cout.flush();
    void* exp_buf = malloc(strlen(exp) / 0x2);
    from_hexstring(exp, exp_buf);
    assert(memcmp(msg, exp_buf, msg_len) == 0, "encrypt_test() : bad");
    free(exp_buf, strlen(exp) / 0x2);
}

void encrypt_test(void* key, void* nonce, u8* msg, u8* exp) {
    u64 len = strlen(msg);
    void* buf = malloc(len);
    memcpy(buf, $void* msg, len);
    encrypt_test(key, nonce, buf, len, exp);
    free(buf, len);
}

i32 main() {
    // https://datatracker.ietf.org/doc/html/rfc8439
    {
        void* key = malloc($u64 32);
        void* nonce = malloc($u64 12);

        from_hexstring("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f", key);
        from_hexstring("000000000000004a00000000", nonce);

        keystream_test(key, nonce, $u64 64);
        encrypt_test(
            key, nonce, 
            "Ladies and Gentlemen of the class of \'99: If I could offer you only one tip for the future, sunscreen would be it.",
            "6e2e359a2568f98041ba0728dd0d6981e97e7aec1d4360c20a27afccfd9fae0bf91b65c5524733ab8f593dabcd62b3571639d624e65152ab8f530c359f0861d807ca0dbf500d6a6156a38e088a22b65e52bc514d16ccf806818ce91ab77937365af90bbf74a35be6b40b8eedf2785e42874d"
        );
    }

    cout << "all tests passed\n";
    return 0;
}
#include <iostream>;
#include <assert>;
#include <crypto/X25519>;
#include <intx>;

//all tests taken from https://datatracker.ietf.org/doc/html/rfc7748

string keystring(void* key) {
    return to_hexstring(key, $u64 32);
}

string to_hexstring(void* buf, u64 len) {
    string res = new string(len * 0x2, ' ');
    for(u64 i = 0x0; i < $u64 len; i++) {
        u64 lo = $u64 ($u8* buf)[i] & 0x0F;
        u64 hi = $u64 ($u8* buf)[i] & 0xF0;
        hi >>= $u64 4;
        if(hi < $u64 10) res[i * 0x2 + 0x0] = ('0' + $u8 hi);
        else res[i * 0x2 + 0x0] = ('a' + $u8 hi - $u8 10);
        if(lo < $u64 10) res[i * 0x2 + 0x1] = ('0' + $u8 lo);
        else res[i * 0x2 + 0x1] = ('a' + $u8 lo - $u8 10);
    }
    return res;
}

string to_hexstring_le(u512 x) {
    string res = new string($u64 128, ' ');
    u8* p = ($u8* @x);
    u8* hex = "0123456789abcdef";
    for(i32 i = 0; i < 64; i++) {
        u8 b = p[i];
        res[i * 2 + 0] = hex[b >> $u8 4];
        res[i * 2 + 1] = hex[b & $u8 0xF];
    }
    return res;
}

//interprets the given hex string as little endian
u512 from_hexstring(u8* str) {
    u64 len = strlen(str);
    assert(len <= $u64 128, "hexstring too big");
    assert((len % 0x2) == 0x0, "hexstring invalid");
    u512 res;
    u64 shift = 0x0;
    for(u64 i = 0x0; i < len; i++) {
        u8 dig = str[i];
        if('0' <= dig && dig <= '9') dig -= '0';
        else if('a' <= dig && dig <= 'f') dig -= 'a' - $u8 10;
        else if('A' <= dig && dig <= 'F') dig -= 'A' - $u8 10;
        else assert(0, "parse hexstring failed");
        u64 cshift = shift;
        if(i % 0x2) cshift -= 0x4;
        else cshift += 0x4;
        res += new u512($u64 dig) << cshift;
        shift += 0x4;
    }
    return res;
}   

void print_u512_le(u512 x) {
    cout << to_hexstring_le(x);
}

void mul_test(u512 s, u512 x, string exp) {
    u512 out = X25519(s, x);
    string rstr = to_hexstring($void* @out, $u64 32);
    cout << "R : " << rstr << "\n";
    cout.flush();
    assert(rstr == exp, "mul_test() : incorrect");
}

//doing 1000 iters takes too long for now
void iter_test(u512 init, string exp1, string exp1000) {
    u512 s = init;
    u512 x = init;
    for(i32 i = 1; i <= 1; i++) {
        u512 out = X25519(s, x);

        string str = to_hexstring($void* @out, $u64 32);
        if(i == 1) assert(str == exp1, "iter_test() : wrong 1");
        else if(i == 1000) assert(str == exp1000, "iter_test() : wrong 1000");

        x = s;
        s = out;
    }
}

//testing generating a shared secret
void exchange_test(u512 prka, u512 prkb, string exp_puka, string exp_pukb, string exp_shared) {
    //compute public keys
    u512 puka = X25519(prka);
    u512 pukb = X25519(prkb);
    cout << "PUKA : " << to_hexstring($void* @puka, $u64 32) << "\n";
    cout << "PUKB : " << to_hexstring($void* @pukb, $u64 32) << "\n";
    assert(to_hexstring($void* @puka, $u64 32) == exp_puka);
    assert(to_hexstring($void* @pukb, $u64 32) == exp_pukb);

    //compute shared key
    u512 sha = X25519(prka, pukb);
    u512 shb = X25519(prkb, puka);
    cout << "SHA : " << to_hexstring($void* @sha, $u64 32) << "\n";
    cout << "SHB : " << to_hexstring($void* @shb, $u64 32) << "\n";
    assert(to_hexstring($void* @sha, $u64 32) == exp_shared);
    assert(to_hexstring($void* @shb, $u64 32) == exp_shared);
}

i32 main() {

    mul_test(
        from_hexstring("a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4"),
        from_hexstring("e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c"),
        new string("c3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552")
    );

    mul_test(
        from_hexstring("4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d"),
        from_hexstring("e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493"),
        new string("95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957")
    );

    iter_test(
        from_hexstring("0900000000000000000000000000000000000000000000000000000000000000"),
        new string("422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079"),
        new string("684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51")
    );

    exchange_test(
        from_hexstring("77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a"),
        from_hexstring("5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb"),
        new string("8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a"),
        new string("de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f"),
        new string("4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742")
    );

    cout << "all tests passed\n";
    return 0;
}
.section .text
# main()
.global _start
_start:
    # start initialize global variables
    mov %rsp, %r15
    sub $128, %rsp
    mov %rsp, %rbp
    # initialize global variable : u64 PROT_NONE
    movq $0, 0(%r15)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable PROT_NONE
    mov 0(%r15), %rax
    lea 0(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 PROT_NONE
    # initialize global variable : u64 PROT_READ
    movq $0, 8(%r15)
    mov $1, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable PROT_READ
    mov 8(%r15), %rax
    lea 8(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 PROT_READ
    # initialize global variable : u64 PROT_WRITE
    movq $0, 16(%r15)
    mov $2, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable PROT_WRITE
    mov 16(%r15), %rax
    lea 16(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 PROT_WRITE
    # initialize global variable : u64 PROT_EXEC
    movq $0, 24(%r15)
    mov $4, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable PROT_EXEC
    mov 24(%r15), %rax
    lea 24(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 PROT_EXEC
    # initialize global variable : u64 MAP_PRIVATE
    movq $0, 32(%r15)
    mov $1, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    movsxd %eax, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    shl %cl, %rax
    pop %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable MAP_PRIVATE
    mov 32(%r15), %rax
    lea 32(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 MAP_PRIVATE
    # initialize global variable : u64 MAP_ANONYMOUS
    movq $0, 40(%r15)
    mov $5, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    movsxd %eax, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    shl %cl, %rax
    pop %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable MAP_ANONYMOUS
    mov 40(%r15), %rax
    lea 40(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 MAP_ANONYMOUS
    # initialize global variable : void* nullptr
    movq $0, 48(%r15)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable nullptr
    mov 48(%r15), %rax
    lea 48(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : void* nullptr
    # initialize global variable : u64 PAGE_SIZE
    movq $0, 56(%r15)
    mov $4096, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable PAGE_SIZE
    mov 56(%r15), %rax
    lea 56(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 PAGE_SIZE
    # initialize global variable : u64 MEM_USED
    movq $0, 64(%r15)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable MEM_USED
    mov 64(%r15), %rax
    lea 64(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 MEM_USED
    # initialize global variable : i32 STDIN
    movq $0, 72(%r15)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable STDIN
    mov 72(%r15), %rax
    lea 72(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize global variable : i32 STDIN
    # initialize global variable : i32 STDOUT
    movq $0, 80(%r15)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable STDOUT
    mov 80(%r15), %rax
    lea 80(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize global variable : i32 STDOUT
    # initialize global variable : i32 STDERR
    movq $0, 88(%r15)
    mov $2, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable STDERR
    mov 88(%r15), %rax
    lea 88(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize global variable : i32 STDERR
    # initialize global variable : u64 CLOCK_REALTIME
    movq $0, 96(%r15)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable CLOCK_REALTIME
    mov 96(%r15), %rax
    lea 96(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 CLOCK_REALTIME
    # initialize global variable : u64 CLOCK_MONOTONIC
    movq $0, 104(%r15)
    mov $1, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable CLOCK_MONOTONIC
    mov 104(%r15), %rax
    lea 104(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u64 CLOCK_MONOTONIC
    # initialize global variable : ostream cout
    mov $12, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct ostream
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movq $0, (%rax)
    add $8, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory ostream
    movq %rax, 112(%r15)
    # calling constructor : ostream
    mov $12, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct ostream
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movq $0, (%rax)
    add $8, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory ostream
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:0
    sub $8, %rsp
    movq $0, -24(%rbp)
    # load variable STDOUT
    mov 80(%r15), %rax
    lea 80(%r15), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:0
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L10
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    # expression struct assignment tmp variable
    push %rax    # TMP:1
    # load variable cout
    mov 112(%r15), %rax
    mov 112(%r15), %rcx
    # calling constructor : ostream
    # initialize struct ostream
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movq $0, (%rax)
    add $8, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory ostream
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:2
    sub $8, %rsp
    # load variable TMP:1
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    # dereferencing to type ostream
    mov %rax, %rcx
    movq %rcx, -32(%rbp)
    call L11
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # done initialize global variable : ostream cout
    # initialize global variable : u8* jstring_f32_base2
    movq $0, 120(%r15)
    # calling function : malloc
    # function call member variable : sz
    # TMP:3
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $512, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:3
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L23
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable jstring_f32_base2
    mov 120(%r15), %rax
    lea 120(%r15), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize global variable : u8* jstring_f32_base2
    # done initialize global variables
    push %rbp
    mov %rsp, %rbp
    # calling function : vec2_test
    call L25
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    # calling function : ostream_test
    call L26
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    # calling function : puts_endl
    # function call member variable : s
    # TMP:4
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $17, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $97, %al
    movb %al, (%rbx)
    inc %rbx
    movb $108, %al
    movb %al, (%rbx)
    inc %rbx
    movb $108, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $116, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $116, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $112, %al
    movb %al, (%rbx)
    inc %rbx
    movb $97, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $100, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:4
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L35
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # TMP:5
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:5
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    mov -8(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $0, %rsp
    push %rax
    call sys_exit
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp

# vec2_test()
L25:
    push %rbp
    mov %rsp, %rbp
    # initialize local variable : vec2 a
    # a
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -8(%rbp)
    # calling constructor : vec2
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:6
    sub $8, %rsp
    movq $0, -32(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:6
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # TMP:7
    sub $8, %rsp
    movq $0, -40(%rbp)
    mov $2, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:7
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L3
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    # expression struct assignment tmp variable
    push %rax    # TMP:8
    # load variable a
    mov -8(%rbp), %rax
    mov -8(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:9
    sub $8, %rsp
    # load variable TMP:8
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -40(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # done initialize local variable : vec2 a
    # initialize local variable : vec2 b
    # b
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -16(%rbp)
    # calling constructor : vec2
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:10
    sub $8, %rsp
    movq $0, -40(%rbp)
    mov $3, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:10
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # TMP:11
    sub $8, %rsp
    movq $0, -48(%rbp)
    mov $4, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:11
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L3
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    # expression struct assignment tmp variable
    push %rax    # TMP:12
    # load variable b
    mov -16(%rbp), %rax
    mov -16(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:13
    sub $8, %rsp
    # load variable TMP:12
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -48(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # done initialize local variable : vec2 b
    # initialize local variable : vec2 c
    # c
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -24(%rbp)
    # calling overload : 
    # TMP:14
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -32(%rbp)
    # load variable a
    mov -8(%rbp), %rax
    mov -8(%rbp), %rcx
    # expression struct assignment tmp variable
    push %rax    # TMP:15
    # load variable TMP:14
    mov -32(%rbp), %rax
    mov -32(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:16
    sub $8, %rsp
    # load variable TMP:15
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -64(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # TMP:17
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -40(%rbp)
    # load variable b
    mov -16(%rbp), %rax
    mov -16(%rbp), %rcx
    # expression struct assignment tmp variable
    push %rax    # TMP:18
    # load variable TMP:17
    mov -40(%rbp), %rax
    mov -40(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:19
    sub $8, %rsp
    # load variable TMP:18
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -72(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    call L40
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    movq -32(%rbp), %rax
    # calling destructor : vec2
    push %rax    # DestructorCall::emit_asm() : target struct
    call L4
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $8, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    movq -40(%rbp), %rax
    # calling destructor : vec2
    push %rax    # DestructorCall::emit_asm() : target struct
    call L4
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $8, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # expression struct assignment tmp variable
    push %rax    # TMP:20
    # load variable c
    mov -24(%rbp), %rax
    mov -24(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:21
    sub $8, %rsp
    # load variable TMP:20
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -56(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # done initialize local variable : vec2 c
    # load variable c
    mov -24(%rbp), %rax
    mov -24(%rbp), %rcx
    # calling function : print
    push %rax    # FunctionCall::emit_asm() : target struct
    call L0
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    # FunctionCall::emit_asm() : target struct
    add $8, %rsp
    # calling function : assert
    # function call member variable : x
    # TMP:22
    sub $8, %rsp
    movq $0, -32(%rbp)
    # calling overload : 
    # TMP:23
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -40(%rbp)
    # load variable c
    mov -24(%rbp), %rax
    mov -24(%rbp), %rcx
    # expression struct assignment tmp variable
    push %rax    # TMP:24
    # load variable TMP:23
    mov -40(%rbp), %rax
    mov -40(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:25
    sub $8, %rsp
    # load variable TMP:24
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -72(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # TMP:26
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -48(%rbp)
    # calling constructor : vec2
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:27
    sub $8, %rsp
    movq $0, -72(%rbp)
    mov $4, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:27
    mov -72(%rbp), %rax
    lea -72(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # TMP:28
    sub $8, %rsp
    movq $0, -80(%rbp)
    mov $6, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:28
    mov -80(%rbp), %rax
    lea -80(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L3
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    # expression struct assignment tmp variable
    push %rax    # TMP:29
    # load variable TMP:26
    mov -48(%rbp), %rax
    mov -48(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:30
    sub $8, %rsp
    # load variable TMP:29
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -80(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    call L44
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    movq -40(%rbp), %rax
    # calling destructor : vec2
    push %rax    # DestructorCall::emit_asm() : target struct
    call L4
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $8, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    movq -48(%rbp), %rax
    # calling destructor : vec2
    push %rax    # DestructorCall::emit_asm() : target struct
    call L4
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $8, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:22
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L38
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    movq -8(%rbp), %rax
    # calling destructor : vec2
    push %rax    # DestructorCall::emit_asm() : target struct
    call L4
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $8, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    movq -16(%rbp), %rax
    # calling destructor : vec2
    push %rax    # DestructorCall::emit_asm() : target struct
    call L4
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $8, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    movq -24(%rbp), %rax
    # calling destructor : vec2
    push %rax    # DestructorCall::emit_asm() : target struct
    call L4
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $8, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $24, %rsp
    # calling function : puts_endl
    # function call member variable : s
    # TMP:31
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $17, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $118, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $99, %al
    movb %al, (%rbx)
    inc %rbx
    movb $50, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $116, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $116, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $112, %al
    movb %al, (%rbx)
    inc %rbx
    movb $97, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $100, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:31
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L35
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    pop %rbp
    ret

# assert(u64)
L39:
    push %rbp
    mov %rsp, %rbp
    # if statement start
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    test %rax, %rax
    sete %al
    movzx %al, %rax
    cmp $0, %rax
    jne L51
    jmp L52
L51:
    # calling function : puts_endl
    # function call member variable : s
    # TMP:32
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $14, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $97, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $114, %al
    movb %al, (%rbx)
    inc %rbx
    movb $116, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $102, %al
    movb %al, (%rbx)
    inc %rbx
    movb $97, %al
    movb %al, (%rbx)
    inc %rbx
    movb $105, %al
    movb %al, (%rbx)
    inc %rbx
    movb $108, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $100, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:32
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L35
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # calling function : sys_exit
    # function call member variable : status
    # TMP:33
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:33
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L13
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    jmp L52
L52:
    # if statement end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    pop %rbp
    ret

# assert(i32)
L38:
    push %rbp
    mov %rsp, %rbp
    # if statement start
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    test %eax, %eax
    sete %al
    movzx %al, %rax
    cmp $0, %rax
    jne L53
    jmp L54
L53:
    # calling function : puts_endl
    # function call member variable : s
    # TMP:34
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $14, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $97, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $115, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $114, %al
    movb %al, (%rbx)
    inc %rbx
    movb $116, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $102, %al
    movb %al, (%rbx)
    inc %rbx
    movb $97, %al
    movb %al, (%rbx)
    inc %rbx
    movb $105, %al
    movb %al, (%rbx)
    inc %rbx
    movb $108, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $100, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:34
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L35
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # calling function : sys_exit
    # function call member variable : status
    # TMP:35
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:35
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L13
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    jmp L54
L54:
    # if statement end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    pop %rbp
    ret

# puti_endl(i32)
L37:
    push %rbp
    mov %rsp, %rbp
    # calling function : puts_endl
    # function call member variable : s
    # TMP:36
    sub $8, %rsp
    movq $0, -8(%rbp)
    # calling function : to_string
    # function call member variable : x
    # TMP:37
    sub $8, %rsp
    movq $0, -16(%rbp)
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:37
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L31
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:36
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L35
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    pop %rbp
    ret

# puti(i32)
L36:
    push %rbp
    mov %rsp, %rbp
    # calling function : puts
    # function call member variable : s
    # TMP:38
    sub $8, %rsp
    movq $0, -8(%rbp)
    # calling function : to_string
    # function call member variable : x
    # TMP:39
    sub $8, %rsp
    movq $0, -16(%rbp)
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:39
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L31
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:38
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L34
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    pop %rbp
    ret

# puts_endl(u8*)
L35:
    push %rbp
    mov %rsp, %rbp
    # calling function : sys_write
    # function call member variable : fd
    # TMP:40
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:40
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # function call member variable : buf
    # TMP:41
    sub $8, %rsp
    movq $0, -16(%rbp)
    # load variable s
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:41
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # function call member variable : count
    # TMP:42
    sub $8, %rsp
    movq $0, -24(%rbp)
    # calling function : strlen
    # function call member variable : s
    # TMP:43
    sub $8, %rsp
    movq $0, -32(%rbp)
    # load variable s
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:43
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L29
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:42
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L14
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $24, %rsp
    # calling function : sys_write
    # function call member variable : fd
    # TMP:44
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:44
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # function call member variable : buf
    # TMP:45
    sub $8, %rsp
    movq $0, -16(%rbp)
    mov $2, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $10, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:45
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # function call member variable : count
    # TMP:46
    sub $8, %rsp
    movq $0, -24(%rbp)
    mov $1, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:46
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L14
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $24, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    pop %rbp
    ret

# puts(u8*)
L34:
    push %rbp
    mov %rsp, %rbp
    # calling function : sys_write
    # function call member variable : fd
    # TMP:47
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:47
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # function call member variable : buf
    # TMP:48
    sub $8, %rsp
    movq $0, -16(%rbp)
    # load variable s
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:48
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # function call member variable : count
    # TMP:49
    sub $8, %rsp
    movq $0, -24(%rbp)
    # calling function : strlen
    # function call member variable : s
    # TMP:50
    sub $8, %rsp
    movq $0, -32(%rbp)
    # load variable s
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:50
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L29
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:49
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L14
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $24, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    pop %rbp
    ret

# to_string(f32)
L33:
    push %rbp
    mov %rsp, %rbp
    # initialize local variable : u32 fbits
    # fbits
    sub $8, %rsp
    movq $0, -8(%rbp)
    # load variable f
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    mov %rcx, %rax
    # dereferencing to type u32
    mov %rax, %rcx
    movl (%rax), %eax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable fbits
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : u32 fbits
    # initialize local variable : u32 sgn
    # sgn
    sub $8, %rsp
    movq $0, -16(%rbp)
    mov $31, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    sal %cl, %eax
    pop %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable fbits
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    and %rbx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable sgn
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : u32 sgn
    # initialize local variable : u32 exp
    # exp
    sub $8, %rsp
    movq $0, -24(%rbp)
    mov $23, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $8, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    sal %cl, %eax
    pop %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    sub %ebx, %eax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    sal %cl, %eax
    pop %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable fbits
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    and %rbx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable exp
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : u32 exp
    # initialize local variable : u32 mantissa
    # mantissa
    sub $8, %rsp
    movq $0, -32(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $23, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    sal %cl, %eax
    pop %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    sub %ebx, %eax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable fbits
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    and %rbx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable mantissa
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : u32 mantissa
    mov $31, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable sgn
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    shr %cl, %eax
    pop %rcx
    movl %eax, (%rcx)
    mov $23, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable exp
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    shr %cl, %eax
    pop %rcx
    movl %eax, (%rcx)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable mantissa
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    shr %cl, %eax
    pop %rcx
    movl %eax, (%rcx)
    mov $23, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    sal %cl, %eax
    pop %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable mantissa
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    or %rbx, %rax
    movl %eax, (%rcx)
    # initialize local variable : u8* base2
    # base2
    sub $8, %rsp
    movq $0, -40(%rbp)
    # load variable jstring_f32_base2
    mov 120(%r15), %rax
    lea 120(%r15), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable base2
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u8* base2
    # for loop start
    # initialize local variable : i32 i
    # i
    sub $8, %rsp
    movq $0, -48(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 i
L55:
    mov $512, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setl %al
    movzx %al, %rax
    cmp $0, %rax
    je L57
    mov $0, %rax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable base2
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable i
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
L56:
    # load variable i
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    incl (%rcx)
    jmp L55
L57:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # initialize local variable : u64 zind
    # zind
    sub $8, %rsp
    movq $0, -48(%rbp)
    mov $255, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable zind
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u64 zind
    # for loop start
    # initialize local variable : u32 i
    # i
    sub $8, %rsp
    movq $0, -56(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : u32 i
L58:
    mov $24, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setb %al
    movzx %al, %rax
    cmp $0, %rax
    je L60
    # initialize local variable : u64 ind
    # ind
    sub $8, %rsp
    movq $0, -64(%rbp)
    mov $23, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    mov %eax, %eax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $127, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable exp
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %eax, %eax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable zind
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %rbx, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    sub %rbx, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %rbx, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    sub %rbx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable ind
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u64 ind
    # if statement start
    # load variable i
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    sal %cl, %eax
    pop %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable mantissa
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    and %rbx, %rax
    cmp $0, %rax
    jne L61
    jmp L62
L61:
    mov $1, %rax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable base2
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ind
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    jmp L62
L62:
    # if statement end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
L59:
    # load variable i
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    incl (%rcx)
    jmp L58
L60:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # initialize local variable : u64 int_por
    # int_por
    sub $8, %rsp
    movq $0, -56(%rbp)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable int_por
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u64 int_por
    # for loop start
    # initialize local variable : i32 i
    # i
    sub $8, %rsp
    movq $0, -64(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 i
L63:
    mov $60, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setl %al
    movzx %al, %rax
    cmp $0, %rax
    je L65
    # if statement start
    # load variable base2
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable zind
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    mov %eax, %eax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    cmp $0, %rax
    jne L66
    jmp L67
L66:
    # load variable i
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1, %rax
    movsxd %eax, %rax
    pop %rbx    # ExprBinary::emit_asm() : save right
    push %rcx
    mov %rbx, %rcx
    shl %cl, %rax
    pop %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable int_por
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %rbx, %rax
    movq %rax, (%rcx)
    jmp L67
L67:
    # if statement end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
L64:
    # load variable i
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    incl (%rcx)
    jmp L63
L65:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # initialize local variable : i32 frac_precision
    # frac_precision
    sub $8, %rsp
    movq $0, -64(%rbp)
    mov $13, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable frac_precision
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 frac_precision
    # initialize local variable : u64 frac_por
    # frac_por
    sub $8, %rsp
    movq $0, -72(%rbp)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable frac_por
    mov -72(%rbp), %rax
    lea -72(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u64 frac_por
    # initialize local variable : u64 pow2
    # pow2
    sub $8, %rsp
    movq $0, -80(%rbp)
    mov $1, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable pow2
    mov -80(%rbp), %rax
    lea -80(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u64 pow2
    # for loop start
    # initialize local variable : i32 i
    # i
    sub $8, %rsp
    movq $0, -88(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 i
L68:
    # load variable frac_precision
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setl %al
    movzx %al, %rax
    cmp $0, %rax
    je L70
    mov $10, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable pow2
    mov -80(%rbp), %rax
    lea -80(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    mul %rbx
    movq %rax, (%rcx)
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
L69:
    # load variable i
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    incl (%rcx)
    jmp L68
L70:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    mov $2, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable pow2
    mov -80(%rbp), %rax
    lea -80(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cqo
    div %rbx
    movq %rax, (%rcx)
    # for loop start
    # initialize local variable : i32 i
    # i
    sub $8, %rsp
    movq $0, -88(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable zind
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    mov %eax, %eax
    pop %rbx    # ExprBinary::emit_asm() : save right
    sub %ebx, %eax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 i
L71:
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setge %al
    movzx %al, %rax
    cmp $0, %rax
    je L73
    # if statement start
    # load variable base2
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable i
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    cmp $0, %rax
    jne L74
    jmp L75
L74:
    # load variable pow2
    mov -80(%rbp), %rax
    lea -80(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable frac_por
    mov -72(%rbp), %rax
    lea -72(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %rbx, %rax
    movq %rax, (%rcx)
    jmp L75
L75:
    # if statement end
    mov $2, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable pow2
    mov -80(%rbp), %rax
    lea -80(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cqo
    div %rbx
    movq %rax, (%rcx)
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
L72:
    # load variable i
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    decl (%rcx)
    jmp L71
L73:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # initialize local variable : u8* int_str
    # int_str
    sub $8, %rsp
    movq $0, -88(%rbp)
    # calling function : to_string
    # function call member variable : x
    # TMP:51
    sub $8, %rsp
    movq $0, -96(%rbp)
    # load variable int_por
    mov -56(%rbp), %rax
    lea -56(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:51
    mov -96(%rbp), %rax
    lea -96(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L32
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable int_str
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u8* int_str
    # initialize local variable : u8* frac_str
    # frac_str
    sub $8, %rsp
    movq $0, -96(%rbp)
    # calling function : to_string
    # function call member variable : x
    # TMP:52
    sub $8, %rsp
    movq $0, -104(%rbp)
    # load variable frac_por
    mov -72(%rbp), %rax
    lea -72(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:52
    mov -104(%rbp), %rax
    lea -104(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L32
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable frac_str
    mov -96(%rbp), %rax
    lea -96(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u8* frac_str
    # initialize local variable : i32 int_len
    # int_len
    sub $8, %rsp
    movq $0, -104(%rbp)
    # calling function : strlen
    # function call member variable : s
    # TMP:53
    sub $8, %rsp
    movq $0, -112(%rbp)
    # load variable int_str
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:53
    mov -112(%rbp), %rax
    lea -112(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L29
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    mov %eax, %eax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable int_len
    mov -104(%rbp), %rax
    lea -104(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 int_len
    # initialize local variable : i32 frac_len
    # frac_len
    sub $8, %rsp
    movq $0, -112(%rbp)
    # calling function : strlen
    # function call member variable : s
    # TMP:54
    sub $8, %rsp
    movq $0, -120(%rbp)
    # load variable frac_str
    mov -96(%rbp), %rax
    lea -96(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:54
    mov -120(%rbp), %rax
    lea -120(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L29
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    mov %eax, %eax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable frac_len
    mov -112(%rbp), %rax
    lea -112(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 frac_len
    # initialize local variable : i32 len
    # len
    sub $8, %rsp
    movq $0, -120(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable frac_precision
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable int_len
    mov -104(%rbp), %rax
    lea -104(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable len
    mov -120(%rbp), %rax
    lea -120(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 len
    # if statement start
    # load variable sgn
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    cmp $0, %rax
    jne L76
    jmp L77
L76:
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable len
    mov -120(%rbp), %rax
    lea -120(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    movl %eax, (%rcx)
    jmp L77
L77:
    # if statement end
    # initialize local variable : u8* out_str
    # out_str
    sub $8, %rsp
    movq $0, -128(%rbp)
    # calling function : malloc
    # function call member variable : sz
    # TMP:55
    sub $8, %rsp
    movq $0, -136(%rbp)
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable len
    mov -120(%rbp), %rax
    lea -120(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:55
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L23
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u8* out_str
    # initialize local variable : i32 ptr
    # ptr
    sub $8, %rsp
    movq $0, -136(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable ptr
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 ptr
    # if statement start
    # load variable sgn
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    cmp $0, %rax
    jne L78
    jmp L79
L78:
    movb $45, %al
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    incl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    jmp L79
L79:
    # if statement end
    # for loop start
    # initialize local variable : i32 i
    # i
    sub $8, %rsp
    movq $0, -144(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 i
L80:
    # load variable int_len
    mov -104(%rbp), %rax
    lea -104(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setl %al
    movzx %al, %rax
    cmp $0, %rax
    je L82
    # load variable int_str
    mov -88(%rbp), %rax
    lea -88(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    incl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
L81:
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    incl (%rcx)
    jmp L80
L82:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    movb $46, %al
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    incl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    # for loop start
    # initialize local variable : i32 i
    # i
    sub $8, %rsp
    movq $0, -144(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 i
L83:
    # load variable frac_len
    mov -112(%rbp), %rax
    lea -112(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable frac_precision
    mov -64(%rbp), %rax
    lea -64(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    sub %ebx, %eax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setl %al
    movzx %al, %rax
    cmp $0, %rax
    je L85
    movb $48, %al
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    incl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
L84:
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    incl (%rcx)
    jmp L83
L85:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # for loop start
    # initialize local variable : i32 i
    # i
    sub $8, %rsp
    movq $0, -144(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 i
L86:
    # load variable frac_len
    mov -112(%rbp), %rax
    lea -112(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setl %al
    movzx %al, %rax
    cmp $0, %rax
    je L88
    # load variable frac_str
    mov -96(%rbp), %rax
    lea -96(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    incl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
L87:
    # load variable i
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    incl (%rcx)
    jmp L86
L88:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    mov $0, %rax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -136(%rbp), %rax
    lea -136(%rbp), %rcx
    incl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    # TMP:56
    sub $8, %rsp
    movq $0, -144(%rbp)
    # load variable out_str
    mov -128(%rbp), %rax
    lea -128(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:56
    mov -144(%rbp), %rax
    lea -144(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -144(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $136, %rsp
    pop %rbp
    ret
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $136, %rsp

# to_string(u64)
L32:
    push %rbp
    mov %rsp, %rbp
    # initialize local variable : u8* str
    # str
    sub $8, %rsp
    movq $0, -8(%rbp)
    # calling function : malloc
    # function call member variable : sz
    # TMP:57
    sub $8, %rsp
    movq $0, -16(%rbp)
    mov $21, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:57
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L23
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u8* str
    # initialize local variable : i32 ptr
    # ptr
    sub $8, %rsp
    movq $0, -16(%rbp)
    mov $20, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable ptr
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 ptr
    mov $0, %rax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    decl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    # if statement start
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %rbx, %rax
    sete %al
    movzx %al, %rax
    cmp $0, %rax
    jne L89
    jmp L90
L89:
    movb $48, %al
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    # TMP:58
    sub $8, %rsp
    movq $0, -24(%rbp)
    # load variable str
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:58
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -24(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $16, %rsp
    pop %rbp
    ret
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    jmp L90
L90:
    # if statement end
    # while loop start
L91:
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %rbx, %rax
    setne %al
    movzx %al, %rax
    cmp $0, %rax
    je L93
    mov $10, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cqo
    div %rbx
    mov %rdx, %rax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : save right
    movb $48, %al
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %bl, %al
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    decl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    mov $10, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cqo
    div %rbx
    movq %rax, (%rcx)
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
L92:
    jmp L91
L93:
    # while loop end
    # TMP:59
    sub $8, %rsp
    movq $0, -24(%rbp)
    # load variable str
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable ptr
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:59
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -24(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $16, %rsp
    pop %rbp
    ret
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp

# to_string(i32)
L31:
    push %rbp
    mov %rsp, %rbp
    # if statement start
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    sete %al
    movzx %al, %rax
    cmp $0, %rax
    jne L94
    jmp L95
L94:
    # TMP:60
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $2, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $48, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:60
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -8(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $0, %rsp
    pop %rbp
    ret
    jmp L95
L95:
    # if statement end
    # initialize local variable : i32 is_neg
    # is_neg
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setl %al
    movzx %al, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable is_neg
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 is_neg
    # if statement start
    # load variable is_neg
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    cmp $0, %rax
    jne L96
    jmp L97
L96:
    mov $1, %rax
    neg %eax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    imul %ebx, %eax
    movl %eax, (%rcx)
    jmp L97
L97:
    # if statement end
    # initialize local variable : u8* str
    # str
    sub $8, %rsp
    movq $0, -16(%rbp)
    # calling function : malloc
    # function call member variable : sz
    # TMP:61
    sub $8, %rsp
    movq $0, -24(%rbp)
    mov $12, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:61
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L23
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u8* str
    # initialize local variable : i32 ptr
    # ptr
    sub $8, %rsp
    movq $0, -24(%rbp)
    mov $11, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable ptr
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 ptr
    mov $0, %rax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    decl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    # while loop start
L98:
    mov $0, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %ebx, %eax
    setne %al
    movzx %al, %rax
    cmp $0, %rax
    je L100
    mov $10, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    movsx %eax, %rax
    movsx %ebx, %rbx
    cqo
    idiv %rbx
    mov %edx, %eax
    push %rax    # ExprBinary::emit_asm() : save right
    movb $48, %al
    movzbl %al, %eax
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    decl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    mov $10, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable x
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    movsx %eax, %rax
    movsx %ebx, %rbx
    cqo
    idiv %rbx
    mov %eax, %eax
    movl %eax, (%rcx)
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
L99:
    jmp L98
L100:
    # while loop end
    # if statement start
    # load variable is_neg
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    cmp $0, %rax
    jne L101
    jmp L102
L101:
    movb $45, %al
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable str
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable ptr
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    decl (%rcx)
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movb %al, (%rbx)
    jmp L102
L102:
    # if statement end
    # TMP:62
    sub $8, %rsp
    movq $0, -32(%rbp)
    # load variable str
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    mov $1, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable ptr
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %ebx, %eax
    movsxd %eax, %rax
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    mov %rcx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:62
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -32(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $24, %rsp
    pop %rbp
    ret
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $24, %rsp

# to_string(i32, u8*)
L30:
    push %rbp
    mov %rsp, %rbp
    # TMP:63
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:63
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -8(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $0, %rsp
    pop %rbp
    ret
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp

# strlen(u8*)
L29:
    push %rbp
    mov %rsp, %rbp
    # for loop start
    # initialize local variable : u64 i
    # i
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $0, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable i
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # done initialize local variable : u64 i
L103:
    # if statement start
    mov $0, %rax
    movzbq %al, %rax

    push %rax    # ExprBinary::emit_asm() : save right
    # load variable s
    mov 16(%rbp), %rax
    lea 16(%rbp), %rcx
    push %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    # load variable i
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rax, %rbx
    pop %rcx    # ExprPostfix::emit_asm() : [] %rcx 1
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 1
    push %rax    # ExprPostfix::emit_asm() : [] %rax 2
    lea (%rax, %rbx, 1), %rax
    mov %rax, %rcx
    pop %rax    # ExprPostfix::emit_asm() : [] %rax 2
    movzbl (%rax, %rbx, 1), %eax
    pop %rbx    # ExprBinary::emit_asm() : save right
    cmp %bl, %al
    sete %al
    movzx %al, %rax
    cmp $0, %rax
    jne L106
    jmp L107
L106:
    # TMP:64
    sub $8, %rsp
    movq $0, -16(%rbp)
    # load variable i
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:64
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -16(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $8, %rsp
    pop %rbp
    ret
    jmp L107
L107:
    # if statement end
L104:
    # load variable i
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    incq (%rcx)
    jmp L103
L105:
    # for loop end
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp

# get_sys_time_ns()
L28:
    push %rbp
    mov %rsp, %rbp
    # initialize local variable : timespec ts
    # ts
    sub $8, %rsp
    mov $16, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct timespec
    push %rax    # emit_initialize_struct() :: save original %rax
    movq $0, (%rax)
    add $8, %rax
    movq $0, (%rax)
    add $8, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory timespec
    movq %rax, -8(%rbp)
    # calling constructor : timespec
    mov $16, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct timespec
    push %rax    # emit_initialize_struct() :: save original %rax
    movq $0, (%rax)
    add $8, %rax
    movq $0, (%rax)
    add $8, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory timespec
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    call L5
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $0, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    # expression struct assignment tmp variable
    push %rax    # TMP:65
    # load variable ts
    mov -8(%rbp), %rax
    mov -8(%rbp), %rcx
    # calling constructor : timespec
    # initialize struct timespec
    push %rax    # emit_initialize_struct() :: save original %rax
    movq $0, (%rax)
    add $8, %rax
    movq $0, (%rax)
    add $8, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory timespec
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:66
    sub $8, %rsp
    # load variable TMP:65
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    # dereferencing to type timespec
    mov %rax, %rcx
    movq %rcx, -40(%rbp)
    call L6
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # done initialize local variable : timespec ts
    # calling function : sys_clock_gettime
    # function call member variable : clock_id
    # TMP:67
    sub $8, %rsp
    movq $0, -16(%rbp)
    # load variable CLOCK_REALTIME
    mov 96(%r15), %rax
    lea 96(%r15), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:67
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    # function call member variable : tp
    # TMP:68
    sub $8, %rsp
    movq $0, -24(%rbp)
    # load variable ts
    mov -8(%rbp), %rax
    mov -8(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:68
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L18
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # TMP:69
    sub $8, %rsp
    movq $0, -16(%rbp)
    # load variable ts
    mov -8(%rbp), %rax
    mov -8(%rbp), %rcx
    # accessing member variable tv_nsec, offset : 8
    lea 8(%rax), %rcx
    lea 8(%rax), %rax
    movq (%rax), %rax
    # done accessing member variable tv_nsec
    push %rax    # ExprBinary::emit_asm() : save right
    mov $1000000000, %rax
    movsxd %eax, %rax
    push %rax    # ExprBinary::emit_asm() : save right
    # load variable ts
    mov -8(%rbp), %rax
    mov -8(%rbp), %rcx
    # accessing member variable tv_sec, offset : 0
    lea 0(%rax), %rcx
    lea 0(%rax), %rax
    movq (%rax), %rax
    # done accessing member variable tv_sec
    pop %rbx    # ExprBinary::emit_asm() : save right
    mul %rbx
    pop %rbx    # ExprBinary::emit_asm() : save right
    add %rbx, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:69
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    mov -16(%rbp), %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    add $8, %rsp
    pop %rbp
    ret
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    movq -8(%rbp), %rax
    # calling destructor : timespec
    push %rax    # DestructorCall::emit_asm() : target struct
    call L7
    pop %rax    # DestructorCall::emit_asm() : target struct
    push %rax    # emit_free() : free addr
    mov $16, %rax
    push %rax    # emit_free() : free sz_bytes
    call L24
    add $16, %rsp
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp

# ostream_test()
L26:
    push %rbp
    mov %rsp, %rbp
    # calling overload : 
    # TMP:70
    sub $8, %rsp
    # calling overload : 
    # TMP:71
    sub $8, %rsp
    # load variable cout
    mov 112(%r15), %rax
    mov 112(%r15), %rcx
    movq %rcx, -16(%rbp)
    # TMP:72
    sub $8, %rsp
    movq $0, -24(%rbp)
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $98, %al
    movb %al, (%rbx)
    inc %rbx
    movb $101, %al
    movb %al, (%rbx)
    inc %rbx
    movb $108, %al
    movb %al, (%rbx)
    inc %rbx
    movb $108, %al
    movb %al, (%rbx)
    inc %rbx
    movb $111, %al
    movb %al, (%rbx)
    inc %rbx
    movb $33, %al
    movb %al, (%rbx)
    inc %rbx
    movb $33, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:72
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L46
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # dereferencing to type ostream
    mov %rax, %rcx
    movq %rcx, -8(%rbp)
    # TMP:73
    sub $8, %rsp
    movq $0, -16(%rbp)
    mov $2, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $10, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:73
    mov -16(%rbp), %rax
    lea -16(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L46
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # dereferencing to type ostream
    mov %rax, %rcx
    # initialize local variable : i32 x
    # x
    sub $8, %rsp
    movq $0, -8(%rbp)
    mov $100, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable x
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # done initialize local variable : i32 x
    # calling overload : 
    # TMP:74
    sub $8, %rsp
    # calling overload : 
    # TMP:75
    sub $8, %rsp
    # calling overload : 
    # TMP:76
    sub $8, %rsp
    # load variable cout
    mov 112(%r15), %rax
    mov 112(%r15), %rcx
    movq %rcx, -32(%rbp)
    # TMP:77
    sub $8, %rsp
    movq $0, -40(%rbp)
    mov $5, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $88, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $58, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:77
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L46
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # dereferencing to type ostream
    mov %rax, %rcx
    movq %rcx, -24(%rbp)
    # TMP:78
    sub $8, %rsp
    movq $0, -32(%rbp)
    # load variable x
    mov -8(%rbp), %rax
    lea -8(%rbp), %rcx
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:78
    mov -32(%rbp), %rax
    lea -32(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L48
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # dereferencing to type ostream
    mov %rax, %rcx
    movq %rcx, -16(%rbp)
    # TMP:79
    sub $8, %rsp
    movq $0, -24(%rbp)
    mov $2, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $10, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:79
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L46
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # dereferencing to type ostream
    mov %rax, %rcx
    # initialize local variable : vec2 a
    # a
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -16(%rbp)
    # calling constructor : vec2
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:80
    sub $8, %rsp
    movq $0, -40(%rbp)
    mov $69, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:80
    mov -40(%rbp), %rax
    lea -40(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    # TMP:81
    sub $8, %rsp
    movq $0, -48(%rbp)
    mov $420, %rax
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:81
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movl %eax, (%rbx)
    call L3
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    # expression struct assignment tmp variable
    push %rax    # TMP:82
    # load variable a
    mov -16(%rbp), %rax
    mov -16(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:83
    sub $8, %rsp
    # load variable TMP:82
    mov -24(%rbp), %rax
    lea -24(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -48(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # done initialize local variable : vec2 a
    # calling overload : 
    # TMP:84
    sub $8, %rsp
    # calling overload : 
    # TMP:85
    sub $8, %rsp
    # calling overload : 
    # TMP:86
    sub $8, %rsp
    # load variable cout
    mov 112(%r15), %rax
    mov 112(%r15), %rcx
    movq %rcx, -40(%rbp)
    # TMP:87
    sub $8, %rsp
    movq $0, -48(%rbp)
    mov $5, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    push %rax    # StringLiteral::emit_asm() : string start
    mov %rax, %rbx
    movb $65, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $58, %al
    movb %al, (%rbx)
    inc %rbx
    movb $32, %al
    movb %al, (%rbx)
    inc %rbx
    movb $0, %al
    movb %al, (%rbx)
    pop %rax    # StringLiteral::emit_asm() : string start
    push %rax    # ExprBinary::emit_asm() : = save right
    # load variable TMP:87
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    mov %rcx, %rbx
    pop %rax    # ExprBinary::emit_asm() : = save right
    movq %rax, (%rbx)
    call L46
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $16, %rsp
    # dereferencing to type ostream
    mov %rax, %rcx
    movq %rcx, -32(%rbp)
    # TMP:88
    sub $8, %rsp
    mov $8, %rax
    push %rax    # emit_malloc() : malloc arg
    call L23
    # emit_malloc() : malloc arg
    add $8, %rsp
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    movq %rax, -40(%rbp)
    # load variable a
    mov -16(%rbp), %rax
    mov -16(%rbp), %rcx
    # expression struct assignment tmp variable
    push %rax    # TMP:89
    # load variable TMP:88
    mov -40(%rbp), %rax
    mov -40(%rbp), %rcx
    # calling constructor : vec2
    # initialize struct vec2
    push %rax    # emit_initialize_struct() :: save original %rax
    movl $0, (%rax)
    add $4, %rax
    movl $0, (%rax)
    add $4, %rax
    pop %rax    # emit_initialize_struct() :: save original %rax
    # done initialize struct memory vec2
    push %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
    push %rax    # ConstructorCall::emit_asm() : target struct
    # TMP:90
    sub $8, %rsp
    # load variable TMP:89
    mov -48(%rbp), %rax
    lea -48(%rbp), %rcx
    # dereferencing to type vec2
    mov %rax, %rcx
    movq %rcx, -72(%rbp)
    call L2
    push %rax    # pop_declaration_stack() : save %rax
    push %rcx    # pop_declaration_stack() : save %rcx
    pop %rcx    # pop_declaration_stack() : save %rcx
    pop %rax    # pop_declaration_stack() : save %rax
    add $8, %rsp
    # ConstructorCall::emit_asm() : target struct
    add $8, %rsp
    pop %rax    # ConstructorCall::emit_asm() : target struct return ref %rax
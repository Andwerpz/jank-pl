#include <jstring>;
#include <assert>;
#include <vector>;
#include <string>;

#global_node IOSTREAM [MALLOC];

[IOSTREAM] ostream cout = new ostream(STDOUT);
[IOSTREAM] istream cin = new istream(STDIN);

struct istream {
    i32 fd;
    u8* buf;
    u64 buf_sz;
    u64 buf_ptr;
    i32 is_eof;     // reached end of file
    i32 is_bad;     // some error occurred while reading

    istream() {
        this.fd = STDIN;
        this.init_buf();
    }

    istream(i32 _fd) {
        this.fd = _fd;
        this.init_buf();
    }

    istream(istream& other) {
        this.fd = other.fd;
        this.init_buf();
    }

    ~istream() {
        free($void* this.buf, $u64 4096);
    }

    void init_buf() {
        this.buf = $u8* malloc($u64 4096);
        this.buf_sz = $u64 0;
        this.buf_ptr = $u64 0;
        this.is_eof = 0;
        this.is_bad = 0;
    }

    void refresh_buf() {
        this.buf_ptr = $u64 0;
        while(1) {
            i64 read_amt = sys_read(this.fd, $void* this.buf, $u64 4096);
            if(read_amt == $i64 -ERR_AGAIN) {
                //yield to scheduler and try again later
                sys_sched_yield();
                continue;
            }
            else if(read_amt < $i64 0) {
                this.is_bad = 1;
                return;
            }
            this.buf_sz = $u64 read_amt;
            break;
        }
        if(this.buf_sz == $u64 0) this.is_eof = 1;
    }

    i32 is_whitespace(u8 c) {
        return c == ' ' || c == '\n' || c == '\t' || c == '\r';
    }

    u8 next_char() {
        while(!this.eof() && !this.bad() && this.buf_ptr == this.buf_sz) this.refresh_buf();
        if(this.eof() || this.bad()) return '\0';
        return this.buf[this.buf_ptr ++];
    }

    //if we hit eof before a token, returns empty string
    string next_token() {
        string tok = new string();

        i32 found_tok = 0;
        while(1) {
            u8 c = this.next_char();
            if(this.eof() || this.bad()) break;
            if(this.is_whitespace(c)) {
                if(found_tok) break;
            }
            else {
                found_tok = 1;
                tok.push_back(c);
            }
        }

        if(!found_tok) return new string();
        return tok;
    }

    string next_line() {
        string line = new string();

        i32 found_line = 0;
        while(1) {
            u8 c = this.next_char();
            if(this.eof() || this.bad()) break;
            if(c == '\n' || c == '\r') {
                if(found_line) break;
            }
            else {
                found_line = 1;
                if(c == '\n' || c == '\r') continue;
                line.push_back(c);
            }
        }

        if(!found_line) return new string();
        return line;
    }

    i32 eof() {
        return this.is_eof;
    }

    i32 bad() {
        return this.is_bad;
    }
}

istream& operator>>(istream& stream, string& s) {
    s = stream.next_token();
    return stream;
}

istream& operator>>(istream& stream, u64& x) {
    x = stou64(stream.next_token());
    return stream;
}

istream& operator>>(istream& stream, i32& x) {
    x = stoi32(stream.next_token());
    return stream;
}


struct ostream {
    i32 fd;
    i32 is_bad;

    ostream() {
        this.fd = STDOUT;
        this.is_bad = 0;
    }

    ostream(i32 _fd) {
        this.fd = _fd;
        this.is_bad = 0;
    }

    ostream(ostream& other) {
        this.fd = other.fd;
    }

    ~ostream() {

    }

    i32 write_to_fd(u8 c) {
        u64 tot = 0x1;
        u64 ptr = 0x0;
        while(ptr != tot) {
            i64 amt = sys_write(this.fd, $void* @c, 0x1);
            if(amt < $i64 0) {
                this.is_bad = 1;
                return 1;
            }
            ptr += $u64 amt;
        }
        return 0;
    }

    i32 write_to_fd(u8* str) {
        u64 tot = strlen(str);
        u64 ptr = 0x0;
        while(ptr != tot) {
            i64 amt = sys_write(this.fd, $void* @(str[ptr]), tot - ptr);
            if(amt < $i64 0) {
                this.is_bad = 1;
                return 1;
            }
            ptr += $u64 amt;
        }
        return 0;
    }

    i32 write_to_fd(string str) {
        return this.write_to_fd(str.jstr());
    }

    i32 bad() {
        return this.is_bad;
    }
}

ostream& operator<<(ostream& stream, u8* s) {
    stream.write_to_fd(s);
    return stream;
}

ostream& operator<<(ostream& stream, i64 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, i32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, i16 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u64 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u16 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u8 c) {
    stream.write_to_fd(c);
    return stream;
}

ostream& operator<<(ostream& stream, f32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, string s) {
    stream.write_to_fd(s);
    return stream;
}

template<T>
ostream& operator<<(ostream& stream, T* ptr) {
    stream.write_to_fd("0x");
    u64 val = $u64 ptr;
    u64 mask = 0b1111;
    for(i32 i = 15; i >= 0; i--){
        u64 dig = (val & (mask << ($u64 i * $u64 4))) >> ($u64 i * $u64 4);
        u8 c;
        if(dig < $u64 10) {
            c = '0' + $u8 dig;
        }
        else {
            c = 'a' + $u8 dig - $u8 10;
        }
        stream.write_to_fd(c);
    }
    return stream;
}

#include <jstring>;
#include <assert>;
#include <vector>;
#include <string>;

#global_node IOSTREAM [MALLOC];

[IOSTREAM] ostream cout = new ostream(STDOUT);
[IOSTREAM] istream cin = new istream(STDIN);

struct istream {
    i32 fd;
    u8* buf;
    u64 buf_sz;
    u64 buf_ptr;
    i32 is_eof;     // reached end of file
    i32 is_bad;     // some error occurred while reading

    istream() {
        this.fd = STDIN;
        this.init_buf();
    }

    istream(i32 _fd) {
        this.fd = _fd;
        this.init_buf();
    }

    istream(istream& other) {
        this.fd = other.fd;
        this.init_buf();
    }

    ~istream() {
        free($void* this.buf, $u64 4096);
    }

    void init_buf() {
        this.buf = $u8* malloc($u64 4096);
        this.buf_sz = $u64 0;
        this.buf_ptr = $u64 0;
        this.is_eof = 0;
        this.is_bad = 0;
    }

    void refresh_buf() {
        this.buf_ptr = $u64 0;
        while(1) {
            i64 read_amt = sys_read(this.fd, $void* this.buf, $u64 4096);
            if(read_amt == $i64 -ERR_AGAIN) {
                //yield to scheduler and try again later
                sys_sched_yield();
                continue;
            }
            else if(read_amt < $i64 0) {
                this.is_bad = 1;
                return;
            }
            this.buf_sz = $u64 read_amt;
            break;
        }
        if(this.buf_sz == $u64 0) this.is_eof = 1;
    }

    i32 is_whitespace(u8 c) {
        return c == ' ' || c == '\n' || c == '\t' || c == '\r';
    }

    // i32 next_char(u8& c) {
    //     while(!this.eof() && !this.bad() && this.buf_ptr == this.buf_sz) this.refresh_buf();
    //     if(this.eof() || this.bad()) return 1;
    //     c = this.buf[this.buf_ptr ++];
    //     return 0;
    // }

    u8 next_char() {
        while(!this.eof() && !this.bad() && this.buf_ptr == this.buf_sz) this.refresh_buf();
        if(this.eof() || this.bad()) return '\0';
        return this.buf[this.buf_ptr ++];
    }

    //if we hit eof before a token, returns empty string
    string next_token() {
        string tok = new string();

        i32 found_tok = 0;
        while(1) {
            u8 c = this.next_char();
            if(this.eof() || this.bad()) break;
            if(this.is_whitespace(c)) {
                if(found_tok) break;
            }
            else {
                found_tok = 1;
                tok.push_back(c);
            }
        }

        if(!found_tok) return new string();
        return tok;
    }
    
    string next_line() {
        string line = new string();

        i32 found_line = 0;
        while(1) {
            u8 c = this.next_char();
            if(this.eof() || this.bad()) break; 
            if(c == '\n') {
                //strip preceding \r
                if(line.size() != 0x0 && line[line.size() - 0x1] == '\r') {
                    line.pop_back();
                }
                break;
            }
            line.push_back(c);
        }
        return line;
    }

    i32 eof() {
        return this.is_eof;
    }

    i32 bad() {
        return this.is_bad;
    }
}

istream& operator>>(istream& stream, string& s) {
    s = stream.next_token();
    return stream;
}

istream& operator>>(istream& stream, u64& x) {
    x = stou64(stream.next_token());
    return stream;
}

istream& operator>>(istream& stream, i32& x) {
    x = stoi32(stream.next_token());
    return stream;
}

// TODO
// - don't alloc strings when printing out numeric types
//   perhaps should just write a c-style method that expects an allocated buffer and puts the 
//   string representation of the number into the buffer. 
struct ostream {
    i32 fd;
    u8* buf;
    u64 buf_ptr;
    i32 is_bad;

    ostream() {
        this.fd = STDOUT;
        this.init_buf();
    }

    ostream(i32 _fd) {
        this.fd = _fd;
        this.init_buf();
    }

    ostream(ostream& other) {
        this.fd = other.fd;
        this.init_buf();
    }

    ~ostream() {
        this.flush();
        free($void* this.buf, $u64 4096);
    }

    void init_buf() {
        this.buf = $u8* malloc($u64 4096);
        this.buf_ptr = $u64 0;
        this.is_bad = 0;
    }

    i32 flush() {
        u64 ptr = 0x0;
        u64 rem = this.buf_ptr;
        this.buf_ptr = 0x0;
        while(rem != 0x0) {
            i64 amt = sys_write(this.fd, $void* ($u64 this.buf + ptr), rem);
            if(amt == $i64 -ERR_AGAIN) {
                //yield to scheduler and try again later
                sys_sched_yield();
                continue;
            }
            if(amt < $i64 0) {
                this.is_bad = 1;
                return 1;
            }
            rem -= $u64 amt;
            ptr += $u64 amt;
        }
        return 0;
    }

    i32 write_to_fd(u8 c) {
        if(this.buf_ptr == $u64 4096) {
            i32 stat = this.flush();
            if(stat) return stat;
        }
        assert(this.buf_ptr < $u64 4096);
        this.buf[this.buf_ptr ++] = c;
        return 0;
    }

    i32 write_to_fd(u8* str, u64 len) {
        u64 ptr = 0x0;
        while(ptr < len) {
            if(this.buf_ptr == $u64 4096) {
                i32 stat = this.flush();
                if(stat) return stat;
            } 

            u64 space = $u64 4096 - this.buf_ptr;
            u64 amt = len - ptr;
            if(amt > space) amt = space;

            memcpy($void* @(this.buf[this.buf_ptr]), $void* @(str[ptr]), amt);
            this.buf_ptr += amt;
            ptr += amt;
        }   
        return 0;
    }

    i32 write_to_fd(u8* str) {
        u64 len = strlen(str);
        return this.write_to_fd(str, len);
    }

    i32 write_to_fd(string str) {
        return this.write_to_fd(str.jstr(), str.size());
    }

    i32 bad() {
        return this.is_bad;
    }
}

ostream& operator<<(ostream& stream, u8* s) {
    stream.write_to_fd(s);
    return stream;
}

ostream& operator<<(ostream& stream, i64 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, i32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, i16 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u64 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u16 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u8 c) {
    stream.write_to_fd(c);
    return stream;
}

ostream& operator<<(ostream& stream, f32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, string s) {
    stream.write_to_fd(s);
    return stream;
}

template<T>
ostream& operator<<(ostream& stream, T* ptr) {
    stream.write_to_fd("0x");
    u64 val = $u64 ptr;
    u64 mask = 0b1111;
    for(i32 i = 15; i >= 0; i--){
        u64 dig = (val & (mask << ($u64 i * $u64 4))) >> ($u64 i * $u64 4);
        u8 c;
        if(dig < $u64 10) {
            c = '0' + $u8 dig;
        }
        else {
            c = 'a' + $u8 dig - $u8 10;
        }
        stream.write_to_fd(c);
    }
    return stream;
}

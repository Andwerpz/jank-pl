#include <jstring>;
#include <assert>;
#include <vector>;
#include <string>;

#global_node IOSTREAM [MALLOC];

[__GLOBAL_FIRST__] i32 STDIN = 0;
[__GLOBAL_FIRST__] i32 STDOUT = 1;
[__GLOBAL_FIRST__] i32 STDERR = 2;

[IOSTREAM] ostream cout = new ostream(STDOUT);
[IOSTREAM] istream cin = new istream(STDIN);

struct istream {
    i32 fd;
    u8* buf;
    u64 buf_sz;
    u64 buf_ptr;
    i32 is_eof;

    istream() {
        this.fd = STDIN;
        this.init_buf();
    }

    istream(i32 _fd) {
        this.fd = _fd;
        this.init_buf();
    }

    istream(istream& other) {
        this.fd = other.fd;
        this.init_buf();
    }

    ~istream() {
        free($void* this.buf, $u64 4096);
    }

    void init_buf() {
        this.buf = $u8* malloc($u64 4096);
        this.buf_sz = $u64 0;
        this.buf_ptr = $u64 0;
        this.is_eof = 0;
    }

    void refresh_buf() {
        this.buf_ptr = $u64 0;
        this.buf_sz = sys_read(this.fd, $void* this.buf, $u64 4096);
        if(this.buf_sz == $u64 0) this.is_eof = 1;
    }

    i32 is_whitespace(u8 c) {
        return c == ' ' || c == '\n' || c == '\t' || c == '\r';
    }

    u8 next_char() {
        while(!this.eof() && this.buf_ptr == this.buf_sz) this.refresh_buf();
        if(this.eof()) return '\0';
        return this.buf[this.buf_ptr ++];
    }

    //if we hit eof before a token, returns empty string
    string next_token() {
        string tok = new string();

        i32 found_tok = 0;
        while(1) {
            u8 c = this.next_char();
            if(this.eof()) break;
            if(this.is_whitespace(c)) {
                if(found_tok) break;
            }
            else {
                found_tok = 1;
                tok.push_back(c);
            }
        }

        if(!found_tok) return new string();
        return tok;
    }

    string next_line() {
        string line = new string();

        i32 found_line = 0;
        while(1) {
            u8 c = this.next_char();
            if(this.eof()) break;
            if(c == '\n' || c == '\r') {
                if(found_line) break;
            }
            else {
                found_line = 1;
                if(c == '\n' || c == '\r') continue;
                line.push_back(c);
            }
        }

        if(!found_line) return new string();
        return line;
    }

    i32 eof() {
        return this.is_eof;
    }
}

istream& operator>>(istream& stream, string& s) {
    s = stream.next_token();
    return stream;
}

istream& operator>>(istream& stream, u64& x) {
    x = stou64(stream.next_token());
    return stream;
}

istream& operator>>(istream& stream, i32& x) {
    x = stoi32(stream.next_token());
    return stream;
}


struct ostream {
    i32 fd;
    u8* scratch_buf;

    ostream() {
        this.fd = STDOUT;
        this.scratch_buf = $u8* malloc($u64 128);
    }

    ostream(i32 _fd) {
        this.fd = _fd;
        this.scratch_buf = $u8* malloc($u64 128);
    }

    ostream(ostream& other) {
        this.fd = other.fd;
    }

    ~ostream() {
        free($void* this.scratch_buf, $u64 128);
    }

    void write_to_fd(u8 c) {
        sys_write(this.fd, $void* @c, 0x1);
    }

    void write_to_fd(u8* str) {
        sys_write(this.fd, $void* str, strlen(str));
    }

    void write_to_fd(string str) {
        sys_write(this.fd, $void* str.arr, str.size());
    }
}

ostream& operator<<(ostream& stream, u8* s) {
    stream.write_to_fd(s);
    return stream;
}

ostream& operator<<(ostream& stream, i64 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, i32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, i16 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u64 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u16 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, u8 c) {
    stream.write_to_fd(c);
    return stream;
}

ostream& operator<<(ostream& stream, f32 x) {
    stream.write_to_fd(to_string(x));
    return stream;
}

ostream& operator<<(ostream& stream, string s) {
    stream.write_to_fd(s);
    return stream;
}

ostream& operator<<(ostream& stream, void* ptr) {
    u64 val = $u64 ptr;
    u64 mask = 0b1111;
    for(i32 i = 15; i >= 0; i--){
        u64 dig = (val & (mask << ($u64 i * $u64 4))) >> ($u64 i * $u64 4);
        u8 c;
        if(dig < $u64 10) {
            c = '0' + $u8 dig;
        }
        else {
            c = 'a' + $u8 dig - $u8 10;
        }
        stream.write_to_fd(c);
    }
    return stream;
}

//these defs should mostly follow what linux has so that it's easy to test

typedef i64 pid_t;              //process id
typedef i32 fd_t;               //file descriptor
typedef u32 mode_t;             //file options (permissions)

[__GLOBAL_FIRST__] i32 STDIN = 0;
[__GLOBAL_FIRST__] i32 STDOUT = 1;
[__GLOBAL_FIRST__] i32 STDERR = 2;

// null terminated list of null terminated strings of form '<name>=<val>'
// this variable is generated by the compiler
// [__GLOBAL_FIRST__] u8** environ;

// sys_wait options
[__GLOBAL_FIRST__] i32 WNOHANG      = $i32 0x01;    // make wait non-blocking 
[__GLOBAL_FIRST__] i32 WUNTRACED    = $i32 0x02;    
[__GLOBAL_FIRST__] i32 WEXITED      = $i32 0x04;    
[__GLOBAL_FIRST__] i32 WCONTINUED   = $i32 0x08;    
[__GLOBAL_FIRST__] i32 WNOWAIT      = $i32 0x10;    // doesn't remove waited child from process table
[__GLOBAL_FIRST__] i32 WTRAPPED     = $i32 0x20;   

// file descriptor flags
// https://codebrowser.dev/linux/linux/include/uapi/asm-generic/fcntl.h.html
[__GLOBAL_FIRST__] i32 O_RDONLY     = $i32 0o00000000;
[__GLOBAL_FIRST__] i32 O_WRONLY     = $i32 0o00000001;
[__GLOBAL_FIRST__] i32 O_RDWR       = $i32 0o00000002;
[__GLOBAL_FIRST__] i32 O_ACCMODE    = $i32 0o00000003;
[__GLOBAL_FIRST__] i32 O_CREAT      = $i32 0o00000100;          // if file doesn't exist and parent directory exists, create a new file there
[__GLOBAL_FIRST__] i32 O_EXCL       = $i32 0o00000200;          // file must not exist initially
[__GLOBAL_FIRST__] i32 O_TRUNC      = $i32 0o00001000;          // discard all contents of the file before writing
[__GLOBAL_FIRST__] i32 O_APPEND     = $i32 0o00002000;          // before each write, kernel sets write head to current end of file
[__GLOBAL_FIRST__] i32 O_DIRECTORY  = $i32 0o00200000;          // fail if the path does not refer to a directory

// look here for rest of defs : 
// https://codebrowser.dev/glibc/glibc/sysdeps/unix/sysv/linux/bits/time.h.html
[__GLOBAL_FIRST__] u64 CLOCK_REALTIME  = $u64 0;           // Identifier for system-wide realtime clock.
[__GLOBAL_FIRST__] u64 CLOCK_MONOTONIC = $u64 1;           // Monotonic system-wide clock.

struct timespec {
    i64 tv_sec;
    i64 tv_nsec;
}

// https://codebrowser.dev/glibc/glibc/dirent/dirent.h.html
[__GLOBAL_FIRST__] u64 DT_UNKNOWN = $u64 0;      // unknown
[__GLOBAL_FIRST__] u64 DT_FIFO    = $u64 1;      // named pipe
[__GLOBAL_FIRST__] u64 DT_CHR     = $u64 2;      // character device
[__GLOBAL_FIRST__] u64 DT_DIR     = $u64 4;      // directory
[__GLOBAL_FIRST__] u64 DT_BLK     = $u64 6;      // block device
[__GLOBAL_FIRST__] u64 DT_REG     = $u64 8;      // regular file
[__GLOBAL_FIRST__] u64 DT_LNK     = $u64 10;     // symbolic link
[__GLOBAL_FIRST__] u64 DT_SOCK    = $u64 12;     // socket
[__GLOBAL_FIRST__] u64 DT_WHT     = $u64 14;     // whiteout (bsd/union mount concept)

//directory entry. don't free dirents that are results from calls, they're managed internally
struct dirent {
    u64 d_ino;          // inode number
    i64 d_off;          // fd position for the next dirent
    u16 d_reclen;       // total length of this dirent (including full null-terminated name)
    u8  d_type;         // some DT type constant
    u8  d_name;         // start of null-terminated name
}

// lseek options
[__GLOBAL_FIRST__] i32 SEEK_SET = 0;
[__GLOBAL_FIRST__] i32 SEEK_CUR = 1;
[__GLOBAL_FIRST__] i32 SEEK_END = 2;

//file information struct
struct stat {
    // the pair (st_dev, st_ino) should be able to uniquely identify a file
    u64 st_dev;         // Device ID of device containing file. 
    u64 st_ino;         // File serial number (inode number)
    u64 st_nlink;       // Number of hard links to the file. 

    u32 st_mode;        // File type + permissions
    u32 st_uid;         // owner UID
    u32 st_gid;         // owner GID
    u32 __pad0;         // padding

    u64 st_rdev;        // Device ID of device files (char and block devices)
    i64 st_size;        // file size in bytes
    i64 st_blksize;     // "optimal" block size (performance hint for user program)
    i64 st_blocks;      // 512-byte blocks allocated

    timespec st_atime;  // access time
    timespec st_mtime;  // modify time
    timespec st_ctime;  // last status change time

    i64[3] __pad1;      // more padding
}

//bits that go into mode_t
// https://codebrowser.dev/glibc/glibc/sysdeps/unix/sysv/linux/bits/stat.h.html
[__GLOBAL_FIRST__] mode_t S_IRWXU  = $mode_t 0o0000700;    // owner access bits
[__GLOBAL_FIRST__] mode_t S_IRUSR  = $mode_t 0o0000400;
[__GLOBAL_FIRST__] mode_t S_IWUSR  = $mode_t 0o0000200;
[__GLOBAL_FIRST__] mode_t S_IXUSR  = $mode_t 0o0000100;

[__GLOBAL_FIRST__] mode_t S_IRWXG  = $mode_t 0o0000070;    // group access bits
[__GLOBAL_FIRST__] mode_t S_IRGRP  = $mode_t 0o0000040;
[__GLOBAL_FIRST__] mode_t S_IWGRP  = $mode_t 0o0000020;
[__GLOBAL_FIRST__] mode_t S_IXGRP  = $mode_t 0o0000010;

[__GLOBAL_FIRST__] mode_t S_IRWXO  = $mode_t 0o0000007;    // other access bits
[__GLOBAL_FIRST__] mode_t S_IROTH  = $mode_t 0o0000004;
[__GLOBAL_FIRST__] mode_t S_IWOTH  = $mode_t 0o0000002;
[__GLOBAL_FIRST__] mode_t S_IXOTH  = $mode_t 0o0000001;

[__GLOBAL_FIRST__] mode_t S_ISUID  = $mode_t 0o0004000;    // set user id on execution 
[__GLOBAL_FIRST__] mode_t S_ISGID  = $mode_t 0o0002000;    // set group id on execution 
[__GLOBAL_FIRST__] mode_t S_ISVTX  = $mode_t 0o0001000;    // save swapped text even after use 

[__GLOBAL_FIRST__] mode_t S_IFMT   = $mode_t 0o0170000;    // these bits tell you the file type
[__GLOBAL_FIRST__] mode_t S_IFIFO  = $mode_t 0o0010000;    // FIFO
[__GLOBAL_FIRST__] mode_t S_IFCHR  = $mode_t 0o0020000;    // character device
[__GLOBAL_FIRST__] mode_t S_IFDIR  = $mode_t 0o0040000;    // directory
[__GLOBAL_FIRST__] mode_t S_IFBLK  = $mode_t 0o0060000;    // block device
[__GLOBAL_FIRST__] mode_t S_IFREG  = $mode_t 0o0100000;    // regular file
[__GLOBAL_FIRST__] mode_t S_IFLNK  = $mode_t 0o0120000;    // symbolic link
[__GLOBAL_FIRST__] mode_t S_IFSOCK = $mode_t 0o0140000;    // socket

//general terminal interface used to control async communications ports
struct termios {
    u32     c_iflag;    // input flags
    u32     c_oflag;    // output flags
    u32     c_cflag;    // control flags
    u32     c_lflag;    // local flags
    u8      c_line;     // line discipline selector (ignore)
    u8[32]  c_cc;       // control chars (VMIN, VTIME, etc.)
    u32     c_ispeed;   // input speed baud rate (ignore)
    u32     c_ospeed;   // output speed baud rate (ignore)
}
[__GLOBAL_FIRST__] u64 TTY_NCCS = $u64 32;

// ioctl request codes for termios
// https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/ioctls.h
[__GLOBAL_FIRST__] u64 TCGETS  = 0x5401;
[__GLOBAL_FIRST__] u64 TCSETS  = 0x5402;
[__GLOBAL_FIRST__] u32 TIOCGWINSZ = $u32 0x5413;

//used in ioctl to extract terminal size
struct winsize {
    u16 ws_row;
    u16 ws_col;
    u16 ws_xpixel;  // often unused
    u16 ws_ypixel;  // often unused
}

// termios flags
// grep -R " ECHO" /usr/include
// - c_iflag
[__GLOBAL_FIRST__] u64 TTY_ICRNL  = $u64 (1 << 8);      //map CR -> NL
[__GLOBAL_FIRST__] u64 TTY_IXON   = $u64 (1 << 10);     //Enable XON/XOFF flow control on output. (?)

// - c_oflag
[__GLOBAL_FIRST__] u64 TTY_OPOST  = $u64 (1 << 0);      //enable tty output processing
[__GLOBAL_FIRST__] u64 TTY_ONLCR  = $u64 (1 << 2);      //map NL -> CR NL

// - c_cflag

// - c_lflag
[__GLOBAL_FIRST__] u64 TTY_ISIG   = $u64 (1 << 0);      //when characters INTR, QUIT, SUSP, DSUSP are recieved, generate the corresponding signal
[__GLOBAL_FIRST__] u64 TTY_ICANON = $u64 (1 << 1);      //enable canonical mode (line discipline)
[__GLOBAL_FIRST__] u64 TTY_ECHO   = $u64 (1 << 3);      //echo input characters
[__GLOBAL_FIRST__] u64 TTY_ECHOE  = $u64 (1 << 4);      //visually delete last typed character on backspace


// indices in c_cc[]
[__GLOBAL_FIRST__] u64 TTY_VERASE = $u64 2;         //what character is the backspace character?
[__GLOBAL_FIRST__] u64 TTY_VTIME  = $u64 5;         //timeout in deciseconds for non-canonical read
[__GLOBAL_FIRST__] u64 TTY_VMIN   = $u64 6;         //minimum number of characters for non-canonical read

// the sockaddr_in and the sockaddr are the same size so we can cast the more
// general sockaddr struct to the more specific sockaddr_in struct
// the address family will always(?) be the first 2 bytes for both.
// we can support more address families this way.
// all the fields here will be in cpu order (little endian)

struct sockaddr {
    u16 sa_family;      // address family
    u8[14] sa_data;     // general data (to be casted to a more specific sockaddr struct type)
}

struct sockaddr_in {
    u16 sin_family;     // address family
    u16 sin_port;       // port
    u32 sin_addr;       // ipv4 address
    u8[8] sin_zero;     // padding
}

// socket parameters
[__GLOBAL_FIRST__] i32 AF_INET = 2;

[__GLOBAL_FIRST__] i32 SOCK_STREAM  = 1;
[__GLOBAL_FIRST__] i32 SOCK_DGRAM   = 2;
[__GLOBAL_FIRST__] i32 SOCK_RAW     = 3;

[__GLOBAL_FIRST__] i32 IPPROTO_ICMP = 1;
[__GLOBAL_FIRST__] i32 IPPROTO_TCP  = 6;
[__GLOBAL_FIRST__] i32 IPPROTO_UDP  = 17;

// recvfrom flags https://docs.huihoo.com/doxygen/linux/kernel/3.7/include_2linux_2socket_8h.html
[__GLOBAL_FIRST__] i32 MSG_DONTWAIT = $i32 0x40;

//used in sys_poll
struct pollfd {
    i32 fd;
    u16 events;
    u16 revents;
}

//pollfd event constants
//https://codebrowser.dev/linux/linux/include/uapi/asm-generic/poll.h.html
[__GLOBAL_FIRST__] u16 POLLIN       = $u16 0x0001;  // there is data to read (a sys_read on this fd will be non-blocking)
[__GLOBAL_FIRST__] u16 POLLPRI      = $u16 0x0002;
[__GLOBAL_FIRST__] u16 POLLOUT      = $u16 0x0004;
[__GLOBAL_FIRST__] u16 POLLERR      = $u16 0x0008;
[__GLOBAL_FIRST__] u16 POLLHUP      = $u16 0x0010;
[__GLOBAL_FIRST__] u16 POLLNVAL     = $u16 0x0020;
#include <time>;

// makes the current process exit with status
// this should always succeed
void sys_exit(i32 status) {
    syscall(60, void, status);
}

// tries to read 'count' bytes from 'fd' to 'buf'. 
// returns the actual amount of bytes read and increments the file pointer
// on failure, returns -1
i64 sys_read(i32 fd, void* buf, u64 count) {
    return syscall(0, i64, fd, buf, count);
}

// writes 'count' bytes from 'buf' to 'fd'
// on success, returns the number of bytes written
// on failure, returns -1
i64 sys_write(i32 fd, void* buf, u64 count) {
    return syscall(1, i64, fd, buf, count);
}

// opens a file descriptor using the path and flags provided
// on success, returns index of file descriptor
// on failure, returns -1
i32 sys_open(u8* path, i32 flags, mode_t mode) { 
    return syscall(2, i32, path, flags, mode);
}

// closes the file descriptor at fd
// on success, returns 0
i32 sys_close(i32 fd) {
    return syscall(3, i32, fd);
}

// sets the end of the data segment to the address specified
// brk(0) returns the current end of the data segment
u64 sys_brk(u64 addr) {
    return syscall(12, u64, addr);
}

// fills the buffer pointed to by buf with up to buf_len random bytes
// apparently on default settings, it's guaranteed that 256 bytes will get written. 
// on success it returns the number of bytes written into the buffer
// on error, it returns -1
i64 sys_getrandom(void* buf, u64 buf_len, u64 flags) {
    return syscall(318, i64, buf, buf_len, flags);
}

// fills the provided timespec struct with the current time in clock 'clock_id'. 
// returns 0 on success, -1 on error. 
i32 sys_clock_gettime(u64 clock_id, timespec* tp) {
    return syscall(228, i32, clock_id, tp);
}

// tells the kernel to map 'len' bytes of memory. 
// If the addr field is non-zero, kernel takes it as a hint as to where to map the memory
// prot_flags are permission flags for the mapped memory
// map_flags are other options. 
// for normal process memory mapping, fd and offset are not needed. 
// on success returns the address, on failure returns $void* $u64 -1
void* sys_mmap(void* addr, u64 len, u64 prot_flags, u64 map_flags, i32 fd, u64 offset) {
    return syscall(9, void*, addr, len, prot_flags, map_flags, fd, offset);
}

// tells the kernel to free 'len' bytes of memory starting from 'addr'. 
// on success returns 0, on failure returns -1
i32 sys_munmap(void* addr, u64 len) {
    return syscall(11, i32, addr, len);
}

// duplicates the calling process, the original process is called the parent and the duplicated process
// is called the child. 
// returns the child PID in the parent and 0 in the child on success
// returns -1 in the parent on failure
pid_t sys_fork() {
    return syscall(57, pid_t);
}

pid_t sys_getpid() {
    return syscall(39, pid_t);
}

// waits on a child to change status
// the exit status of a child is returned through wstatus
// returns the pid of the child on success
pid_t sys_wait4(pid_t pid, i32* wstatus, i32 options, void* rusage) {
    return syscall(61, pid_t, pid, wstatus, options, rusage);
}

// yields the current process to the scheduler. 
// this should always succeed
u64 sys_sched_yield() {
    return syscall(24, u64);
}

// replaces the current process with a new process referred to by path
i32 sys_execve(u8* path, u8** argv, u8** envp) {
    return syscall(59, i32, path, argv, envp);
}

// gets the string representation of the CWD. 
// returns the number of bytes written to the buffer
u64 sys_getcwd(u8* buf, u64 size) {
    return syscall(79, u64, buf, size);
}

// changes the CWD to the one given in path. 
i32 sys_chdir(u8* path) {
    return syscall(80, i32, path);
}

// given that fd is an open file descriptor to a directory, reads in as many dirent structs that will fit
// in the provided buffer.
// returns the amount of bytes written on success
// returns -1 on failure
i64 sys_getdents64(i32 fd, void* buf, u64 count) {
    return syscall(217, i64, fd, buf, count);
}

// creates a pipe, a unidirectional data stream that can be used for inter-process communication
// fds is used to return two newly allocated file descriptors, fds[0] = read end, fds[1] = write end
// returns 0 on success
// returns -1 on failure
i32 sys_pipe(i32[2]* fds) {
    return syscall(22, i32, fds);
}

// allocates a new file descriptor with handle new_fd that refers to the same open file description 
// as old_fd. If there is a pre-existing file descriptor at new_fd, it silently gets deallocated. 
// old_fd and new_fd may be used interchangeably to refer to the same resource
// returns the new file descriptor on success
// returns -1 on failure
i32 sys_dup2(i32 old_fd, i32 new_fd) {
    return syscall(33, i32, old_fd, new_fd);
}

// creates a new directory at the specified path
// the parent of the newly created directory must exist initially
// returns 0 on success
// returns -1 on failure
i32 sys_mkdir(u8* path, mode_t mode) {
    return syscall(83, i32, path, mode);
}

// deletes the directory at the specified path
// the directory must be empty
// returns 0 on success
// returns -1 on failure
i32 sys_rmdir(u8* path) {
    return syscall(84, i32, path);
}

//identical to calling sys_open() with flags equal to O_CREAT | O_WRONLY | O_TRUNC
i32 sys_creat(u8* path, mode_t mode) {
    return syscall(85, i32, path, mode);
}

// removes a link to a non-directory entry at the given path
// returns 0 on success
// returns -1 on failure
i32 sys_unlink(u8* path) {
    return syscall(87, i32, path);
}
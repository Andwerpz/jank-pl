#include <time>;

// makes the current process exit with status
// this should always succeed
void sys_exit(i32 status) {
    syscall(60, void, status);
}

// tries to read 'count' bytes from 'fd' to 'buf'. 
// returns the actual amount of bytes read and increments the file pointer
// on failure, returns -1
i64 sys_read(i32 fd, void* buf, u64 count) {
    return syscall(0, i64, fd, buf, count);
}

// writes 'count' bytes from 'buf' to 'fd'
// on success, returns the number of bytes written
// on failure, returns -1
i64 sys_write(i32 fd, void* buf, u64 count) {
    return syscall(1, i64, fd, buf, count);
}

// opens a file descriptor using the path and flags provided
// on success, returns index of file descriptor
// on failure, returns -1
i32 sys_open(u8* path, i32 flags, mode_t mode) { 
    return syscall(2, i32, path, flags, mode);
}

// closes the file descriptor at fd
// on success, returns 0
i32 sys_close(i32 fd) {
    return syscall(3, i32, fd);
}

// sets the end of the data segment to the address specified
// brk(0) returns the current end of the data segment
u64 sys_brk(u64 addr) {
    return syscall(12, u64, addr);
}

// fills the buffer pointed to by buf with up to buf_len random bytes
// apparently on default settings, it's guaranteed that 256 bytes will get written. 
// on success it returns the number of bytes written into the buffer
// on error, it returns -1
i64 sys_getrandom(void* buf, u64 buf_len, u64 flags) {
    return syscall(318, i64, buf, buf_len, flags);
}

// fills the provided timespec struct with the current time in clock 'clock_id'. 
// returns 0 on success, -1 on error. 
i32 sys_clock_gettime(u64 clock_id, timespec* tp) {
    return syscall(228, i32, clock_id, tp);
}

// tells the kernel to map 'len' bytes of memory. 
// If the addr field is non-zero, kernel takes it as a hint as to where to map the memory
// prot_flags are permission flags for the mapped memory
// map_flags are other options. 
// for normal process memory mapping, fd and offset are not needed. 
// on success returns the address, on failure returns $void* $u64 -1
void* sys_mmap(void* addr, u64 len, u64 prot_flags, u64 map_flags, i32 fd, u64 offset) {
    return syscall(9, void*, addr, len, prot_flags, map_flags, fd, offset);
}

// tells the kernel to free 'len' bytes of memory starting from 'addr'. 
// on success returns 0, on failure returns -1
i32 sys_munmap(void* addr, u64 len) {
    return syscall(11, i32, addr, len);
}

// duplicates the calling process, the original process is called the parent and the duplicated process
// is called the child. 
// returns the child PID in the parent and 0 in the child on success
// returns -1 in the parent on failure
pid_t sys_fork() {
    return syscall(57, pid_t);
}

pid_t sys_getpid() {
    return syscall(39, pid_t);
}

// waits on a child to change status
// the exit status of a child is returned through wstatus
// returns the pid of the child on success
pid_t sys_wait4(pid_t pid, i32* wstatus, i32 options, void* rusage) {
    return syscall(61, pid_t, pid, wstatus, options, rusage);
}

// yields the current process to the scheduler. 
// this should always succeed
u64 sys_sched_yield() {
    return syscall(24, u64);
}

// replaces the current process with a new process referred to by path
i32 sys_execve(u8* path, u8** argv, u8** envp) {
    return syscall(59, i32, path, argv, envp);
}

// gets the string representation of the CWD. 
// returns the number of bytes written to the buffer
u64 sys_getcwd(u8* buf, u64 size) {
    return syscall(79, u64, buf, size);
}

// changes the CWD to the one given in path. 
i32 sys_chdir(u8* path) {
    return syscall(80, i32, path);
}

// given that fd is an open file descriptor to a directory, reads in as many dirent structs that will fit
// in the provided buffer.
// returns the amount of bytes written on success
// returns -1 on failure
i64 sys_getdents64(i32 fd, void* buf, u64 count) {
    return syscall(217, i64, fd, buf, count);
}

// creates a pipe, a unidirectional data stream that can be used for inter-process communication
// fds is used to return two newly allocated file descriptors, fds[0] = read end, fds[1] = write end
// returns 0 on success
// returns -1 on failure
i32 sys_pipe(i32[2]* fds) {
    return syscall(22, i32, fds);
}

// allocates a new file descriptor with handle new_fd that refers to the same open file description 
// as old_fd. If there is a pre-existing file descriptor at new_fd, it silently gets deallocated. 
// old_fd and new_fd may be used interchangeably to refer to the same resource
// returns the new file descriptor on success
// returns -1 on failure
i32 sys_dup2(i32 old_fd, i32 new_fd) {
    return syscall(33, i32, old_fd, new_fd);
}

// creates a new directory at the specified path
// the parent of the newly created directory must exist initially
// returns 0 on success
// returns -1 on failure
i32 sys_mkdir(u8* path, mode_t mode) {
    return syscall(83, i32, path, mode);
}

// deletes the directory at the specified path
// the directory must be empty
// returns 0 on success
// returns -1 on failure
i32 sys_rmdir(u8* path) {
    return syscall(84, i32, path);
}

//identical to calling sys_open() with flags equal to O_CREAT | O_WRONLY | O_TRUNC
i32 sys_creat(u8* path, mode_t mode) {
    return syscall(85, i32, path, mode);
}

// removes a link to a non-directory entry at the given path
// returns 0 on success
// returns -1 on failure
i32 sys_unlink(u8* path) {
    return syscall(87, i32, path);
}

// repositions file offset of fd to the argument off according to whence
// SEEK_SET : position is set to off
// SEEK_CUR : position is incremented by off
// SEEK_END : position is set to EOF + off
i64 sys_lseek(i32 fd, i64 off, i32 whence) {
    return syscall(8, i64, fd, off, whence);
}

// retrieves information about the file pointed to by path
// returns 0 on success
// returns -1 on failure
i32 sys_stat(u8* path, stat* statbuf) {
    return syscall(4, i32, path, statbuf);
}

// retrieves information about the file at fd
// returns 0 on success
// returns -1 on failure
i32 sys_fstat(i32 fd, stat* statbuf) {
    return syscall(5, i32, fd, statbuf);
}

// catch-all syscall to send device-specific information that doesn't work well with other syscalls
// returns 0 on success
// returns -1 on failure
i32 sys_ioctl(i32 fd, u32 op, void* arg) {
    return syscall(16, i32, fd, op, arg);
}

// sets a socket's address
// returns 0 on success
// returns -1 on failure
i32 sys_bind(i32 fd, sockaddr* addr, u64 addr_len) {
    return syscall(49, i32, fd, addr, addr_len);
}

// If src_addr is not NULL, and the underlying protocol provides the source address, this source address is filled in. 
// When src_addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL. 
// The argument addrlen is a value-result argument, which the caller should initialize before the call to the size of the buffer associated with src_addr, 
// and modified on return to indicate the actual size of the source address. The returned address is truncated if the buffer provided is too small; 
// in this case, addrlen will return a value greater than was supplied to the call.
// returns length read
// returns -1 on failure
i64 sys_recvfrom(i32 fd, void* buf, u64 size, i32 flags, sockaddr* src_addr, u64* addr_len) {
    return syscall(45, i64, fd, buf, size, flags, src_addr, addr_len);
}

// creates a socket fd
// returns fd index on success
// returns -1 on failure
i32 sys_socket(i32 domain, i32 type, i32 protocol) {
    return syscall(41, i32, domain, type, protocol);
}

// connects a socket to the addr specified by sockaddr
// returns 0 on success
// returns -1 on failure
i32 sys_connect(i32 fd, sockaddr* addr, u64 len) {
    return syscall(42, i32, fd, addr, len);
}

i32 sys_sendto(i32 fd, void* buf, u64 size, i32 flags, sockaddr* dest_addr, u64 addr_len) {
    return syscall(44, i32, fd, buf, size, flags, dest_addr, addr_len);
}

i32 sys_listen(i32 fd, i32 backlog) {
    return syscall(50, i32, fd, backlog);
}

i32 sys_accept(i32 fd, sockaddr* client_addr, u64* addr_len) {
    return syscall(43, i32, fd, client_addr, addr_len);
}

//fds points to an array of pollfd structs of length nfds
//for each pollfd struct, the revents field gets filled out according to the events currently happening with
// that fd, and the events masked passed in by the user. 
//timeout specifies the number of milliseconds to block for to wait for some event to become true
// timeout < 0 indicates to wait indefinitely
// returns the number of pollfds whose revents fields have been set to a non-negative value
// return value of 0 indicates timeout before any fd became ready
// returns -1 on failure
i32 sys_poll(pollfd* fds, u32 nfds, i32 timeout) {
    return syscall(7, i32, fds, nfds, timeout);
}

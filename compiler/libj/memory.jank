
[__GLOBAL_FIRST__] void* nullptr = $void* $u64 0;

//copies memory from dest to src
//dest and src cannot be overlapping
void* memcpy(void* dest, void* src, u64 count) {
    asm!("mov {dest}, %rdi");
    asm!("mov {src}, %rsi");
    asm!("mov {count}, %rcx");
    asm!("cld");
    asm!("rep movsb");
    return dest;
}

//moves memory from dest to src
//its fine if dest and src are overlapping
void* memmove(void* dest, void* src, u64 count) {
    if (dest == src || count == 0x0) return dest;

    //subtract to avoid overflow
    if(dest > src && ($u64 dest - $u64 src) < count) {
        //backwards
        asm!("mov {dest}, %rdi");
        asm!("mov {src}, %rsi");
        asm!("mov {count}, %rcx");
        asm!("lea -1(%rdi, %rcx), %rdi");   // point dest at end of buffer
        asm!("lea -1(%rsi, %rcx), %rsi");   // point src at end of buffer
        asm!("std");                        // D = 1 : move backwards
        asm!("rep movsb");
        asm!("cld");
    }
    else {
        //forwards
        asm!("mov {dest}, %rdi");
        asm!("mov {src}, %rsi");
        asm!("mov {count}, %rcx");
        asm!("cld");
        asm!("rep movsb");
    }
    return dest;
}

//sets all bytes of memory at ptr to the low byte of val
void* memset(void* ptr, i32 val, u64 count) {
    asm!("mov {ptr}, %rdi");
    asm!("mov {val}, %rax");
    asm!("mov {count}, %rcx");
    asm!("cld");
    asm!("rep stosb");
    return ptr;
}

//returns -1 if lhs < rhs
//returns 0 if lhs == rhs
//returns 1 if lhs > rhs
i32 memcmp(void* lhs, void* rhs, u64 count) {
    for(u64 i = $u64 0; i < count; i++) {
        if(($u8* lhs)[i] < ($u8* rhs)[i]) return -1;
        if(($u8* lhs)[i] > ($u8* rhs)[i]) return 1;
    }
    return 0;
}

template<T, U>
i32 operator==(T* a, U* b) {
    return $u64 a == $u64 b;
}

template<T, U>
i32 operator!=(T* a, U* b) {
    return $u64 a != $u64 b;
}

template<T, U>
i32 operator>(T* a, U* b) {
    return $u64 a > $u64 b;
}

template<T, U>
i32 operator<(T* a, U* b) {
    return $u64 a < $u64 b;
}